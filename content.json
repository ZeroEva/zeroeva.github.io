{"pages":[{"title":"Python 基础","text":"","link":"/Python-基础/index.html"}],"posts":[{"title":"百度翻译API破解 基于Java和Selenium","text":"在一次偶然的情况下, 我对自己提出了一个需求, 那就是把 数据库的所有表格和字段的名称翻译成中文, 但是一个一个地翻译很浪费时间, 于是就想到了翻译引擎。虽说翻译引擎都是有提供的API接口, 但是自己同时为了学习一下爬虫就去尝试着破解百度翻译的翻译接口, 然后就有了接下来的故事了… …说干就干, 打开浏览器,打开百度翻译的界面 F12调出开发人员工具, 然后在Network一栏下, 清空一下最近的请求, 接着就可以开始追接口了:在输入框中随便输点什么之后回车, 发现此时Network下有了几条新的请求(可以点击筛选按钮XHR筛选请求): langdetect：https://fanyi.baidu.com/langdetectv2transapi：https://fanyi.baidu.com/v2transapi当点击langdetect之后, 可以看到Preview/Response一栏中的返回数据, 找到了关键词：zh, 猜测是用来做语言种类识别的二点击v2transapi之后, 同样的观察返回数据, 可以确定是","link":"/2019/02/14/百度翻译API破解 基于Java和Selenium/"},{"title":"Day1 数据类型","text":"Python 的数据类型 Python 中有5中数据类型: 数据类型 示例 整型 255 浮点型 10.24 字符串 zero 布尔 True/False 空类型 None 示例代码1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/bin/env python3# -*- coding: UTF-8 -*-# 输出多行文本print(r'''helloabworld''')# and or not 用法print(True and False)print(True or False)print(not True)x = Noneprint(x)# 将 字符 转换为 Unicode 码print(ord('a'))# 将 Unicode 码转换为 字符print(chr(91))# Python 中几种特殊的表示:# b'xxx': xxx 表示 二进制# f'xxx' 或 F'xxx': xxx 表示 运行时运算求值的表达式 (f-string)# r'xxx': xxx 表示 纯的字符串# u'xxx': xxx 表示 Unicode 编码# 将 字符 转换为 二进制print('我'.encode('UTF-8'))# 将 二进制 转换为 字符print(b'\\xe6\\x88\\xaa'.decode('UTF-8'))print(b'\\x64'.decode('UTF-8'))print(u'\\x64')# 格式化占位符 替换内容# %d 整数# %'2'd '2' 指的是在输出内容中, 格式化后的数据(至少)占的位数，多余的位数补'空格'# %'03'd '3' 指的是在输出内容中, 格式化后的数据(至少)占的位数，多余的位数补'0'# %f 浮点数# %'.2'f '.2' 指的是格式化后的数据保留小数点后 '2', 位数不够的补'0'# %s 字符串# %x 十六进制整数# %% 输出百分号print(f'%2d-%03d' % (3, 1))print('%.2f' % 3.1415926)print('Hello, {0}, 成绩提升了 {1:.2f}%'.format('小明', 17.125))print('growth rate: %d %%' % 7)","link":"/2019/02/12/Python-基础/Day1/"},{"title":"Day2 集合","text":"Python 的集合(数组) 参考自 W3CSchoolPython 共有四种集合: Collection Change Order Duplicate Index Example 列表(List) 可变 有序 元素可重复 无索引 [a, b, a] 元组(Tuple) 不可变 有序 元素可重复 无索引 (a, b, a) 集合(Set) 可变 无序 不可重复 无索引 {a, b} 字典(Dictionary) 可变 无序 不可重复 有索引 {key: value}","link":"/2019/02/12/Python-基础/Day2/"},{"title":"Day1","text":"django 环境安装 在控制台中，输入 pip install django 回车，等待安装完毕，然后输入 python -m django –version 查看版本，如有则安装成功 创建项目在控制台中，输入 django-admin startproject mysite 回车(其中 mysite 是你的项目名称)，则会在当前目录下创建一个名称为 mysite 的项目 目录结构如下:1234567mysite │ manage.py └─mysite │ settings.py │ urls.py │ wsgi.py │ __init__.py ####目录说明: mysite: 项目目录 manage.py: 一个让你用各种方式管理 Django 项目的命令行工具。你可以阅读 django-admin and manage.py 获取所有 manage.py 的细节。 mysite/mysite: 这个目录包含你的项目，它是一个纯 Python 包 mysite/settings.py: Django 项目的配置文件。 mysite/urls.py: Django 项目的 URL 声明，就像你网站的“目录”。 mysite/wsgi.py: 作为你的项目的运行在 WSGI 兼容的Web服务器上的入口。 mysite/__init__.py: 一个空文件，告诉 Python 这个目录应该被认为是一个 Python 包。","link":"/2019/02/14/Django/Day1/"},{"title":"我的简历","text":"Java程序员简历模板本简历模板由国内首家互联网人才拍卖网站「 JobDeer.com 」提供。 （括号里的是我们的顾问编写的说明，建议在简历书写完成后统一删除） 先讲讲怎样才是一份好的技术简历首先，一份好的简历不光说明事实，更通过FAB模式来增强其说服力。 Feature：是什么 Advantage：比别人好在哪些地方 Benefit：如果雇佣你，招聘方会得到什么好处 其次，写简历和写议论文不同，过分的论证会显得自夸，反而容易引起反感，所以要点到为止。这里的技巧是，提供论据，把论点留给阅读简历的人自己去得出。放论据要具体，最基本的是要数字化，好的论据要让人印象深刻。 举个例子，下边内容是虚构的： 2006年，我参与了手机XX网发布系统WAPCMS的开发（这部分是大家都会写的）。作为核心程序员，我不但完成了网站界面、调度队列的开发工作，更提出了高效的组件级缓存系统，通过碎片化缓冲有效的提升了系统的渲染效率。（这部分是很多同学忘掉的，要写出你在这个项目中具体负责的部分，以及你贡献出来的价值。）在该系统上线后，Web前端性能从10QPS提升到200QPS，服务器由10台减少到3台（通过量化的数字来增强可信度）。2008年我升任WAPCMS项目负责人，带领一个3人小组支持着每天超过2亿的PV（这就是Benefit。你能带给前雇主的价值，也就是你能带给新雇主的价值。）。 有同学问，如果我在项目里边没有那么显赫的成绩可以说怎么办？讲不出成绩时，就讲你的成长。因为学习能力也是每家公司都看中的东西。你可以写你在这个项目里边遇到了一个什么样的问题，别人怎么解决的，你怎么解决的，你的方案好在什么地方，最终这个方案的效果如何。 具体、量化、有说服力，是技术简历特别需要注重的地方。 （以上内容在写完简历后，对每一段进行评估，完成后再删除） 联系方式（HR会打印你的简历，用于在面试的时候联系，所以联系方式放到最上边会比较方便） 手机：135** （如果是外地手机，可注明。如经常关机，要写上最优联系时间） Email：goodman@gmail.com （虽然我觉得QQ邮箱无所谓，不过有些技术人员比较反感，建议用G） QQ/微信号：6***（提供一个通过网络可以联系到你的方式） 个人信息 胶布帝/男/1990 本科/萌鹿大学计算机系 工作年限：3年 微博：@JobDeer （如果没有技术相关内容，也可以不放） 技术博客：http://blog.github.io ( 使用GitHub Host的Big较高 ) Github：http://github.com/geekcompany ( 有原创repo的Github帐号会极大的提升你的个人品牌 ) 期望职位：Java高级程序员，架构师 期望薪资：税前月薪15k~20k，特别喜欢的公司可例外 期望城市：北京 工作经历（工作经历按逆序排列，最新的在最前边，按公司做一级分组，公司内按二级分组） ABC公司 （ 2012年9月 ~ 2014年9月 ）DEF项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 GHI项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 其他项目（每个公司写2~3个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。） JKL公司 （ 2010年3月 ~ 2012年8月 ）MNO项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 PQR项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 其他项目（每个公司写2~3个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。） 开源项目和作品（这一段用于放置工作以外的、可证明你的能力的材料） 开源项目（对于程序员来讲，没有什么比Show me the code能有说服力了） STU：项目的简要说明，Star和Fork数多的可以注明 WXYZ：项目的简要说明，Star和Fork数多的可以注明 技术文章（挑选你写作或翻译的技术文章，好的文章可以从侧面证实你的表达和沟通能力，也帮助招聘方更了解你） 一个产品经理眼中的云计算：前生今世和未来 来自HeroKu的HTTP API 设计指南(翻译文章) （ 好的翻译文章可以侧证你对英文技术文档的阅读能力） 演讲和讲义（放置你代表公司在一些技术会议上做过的演讲，以及你在公司分享时制作的讲义） 2014架构师大会演讲：如何通过Docker优化内部开发 9月公司内部分享：云计算的前生今世 技能清单（我一般主张将技能清单写入到工作经历里边去。不过很难完整，所以有这么一段也不错） 以下均为我熟练使用的技能 Web开发：PHP/Hack/Node Web框架：ThinkPHP/Yaf/Yii/Lavaral/LazyPHP 前端框架：Bootstrap/AngularJS/EmberJS/HTML5/Cocos2dJS/ionic 前端工具：Bower/Gulp/SaSS/LeSS/PhoneGap 数据库相关：MySQL/PgSQL/PDO/SQLite 版本管理、文档和自动化部署工具：Svn/Git/PHPDoc/Phing/Composer 单元测试：PHPUnit/SimpleTest/Qunit 云和开放平台：SAE/BAE/AWS/微博开放平台/微信应用开发 参考技能关键字本技能关键字列表是从最近招聘Java的数百份JD中统计出来的，括号中是出现的词频。如果你的简历要投递给有机器（简历分选系统）和不如机器（不懂技术的HR）筛选简历环节的地方，请一定从下边高频关键词中选择5～10个适合你自己的。 java(730) spring(305) web(260) mysql(250) oracle(207) linux(198) j2ee(182) javascript(177) sql(176) hibernate(169) html(139) tomcat(132) struts(128) jquery(116) jsp(106) ajax(96) css(94) ibatis(84) mvc(77) servlet(71) xml(70) js(62) eclipse(51) mybatis(51) jboss(47) struts2(47) weblogic(46) redis(46) apache(45) http(44) shell(39) python(38) hadoop(37) nosql(35) ssh(35) sqlserver(33) mongodb(33) svn(32) uml(32) json(27) unix(27) maven(27) nginx(26) webservice(25) jdbc(24) memcached(23) tcp(22) resin(22) jvm(21) socket(21) db2(19) springmvc(19) websphere(16) soa(16) mina(14) android(14) extjs(13) erp(12) memcache(12) api(11) jetty(11) myeclipse(11) ext(10) git(10) jpa(10) svm(9) php(9) jms(9) ruby(9) lucene(8) html5(8) postgresql(8) crm(7) javaee(7) sybase(7) freemarker(6) cache(6) jsf(6) j2se(6) jbpm(6) cvs(6) junit(6) visio(6) netty(6) hbase(6) nio(6) powerdesigner(6) oo(6) aop(6) workflow(5) restful(5) ios(5) ant(5) mssql(5) orm(5) rose(5) solr(5) webwork(5) zookeeper(4) soap(4) o2o(4) wap(4) cxf(4) thrift(4) xmpp(3) p2p(3) javabean(3) jee(3) hdfs(3) dom(3) hibernate3(3) 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。","link":"/2019/02/15/My/简历/"},{"title":"RabbitMQ 生产确认和消费确认(保证数据的幂等性)","text":"生产确认在生产者生产数据之后发送到RabbitMQ服务器之后，为了确认服务器接收到没，RabbitMQ提供了两个方式： AMQP 中的事务机制 服务器Confirm模式 事务模式事务模式是在代码层面，在发送消息前开启事务，发送完消息后进行commit，这样对于系统的开销会很大 txSelect、txCommit、txRollbacktxSelect: 用户将当前channel设置成transaction模式txCommit: 用于提交事务txRollback: 用于回滚事务 示例: 消费者 TxReceive.java 1234567891011121314151617181920212223242526272829package rabbit.example.confirm;import com.rabbitmq.client.Channel;import rabbit.support.MqFactory;import util.TimeUtil;import java.io.IOException;import java.nio.charset.StandardCharsets;/** * @author 郝雪峰 * @version V1.0 * @date 创建时间：2019/2/18 16:24 */public class TxReceive { public static void main(String[] args) throws IOException { Channel channel = MqFactory.getChannel(); channel.queueDeclare(TxSend.QUEUE_NAME, false, false, false, null); channel.basicConsume(TxSend.QUEUE_NAME, true, (consumerTag, delivery) -&gt; { String message = new String(delivery.getBody(), StandardCharsets.UTF_8); System.out.println(TimeUtil.logNow() + \" [-] TxReceive '\" + message + \"'\"); }, consumerTag -&gt; { }); }} 生产者 TxSend.java 12345678910111213141516171819202122232425262728293031323334353637383940package rabbit.example.confirm;import com.rabbitmq.client.Channel;import rabbit.support.MqFactory;import java.io.IOException;import java.util.concurrent.TimeoutException;/** * @author 郝雪峰 * @version V1.0 * @date 创建时间：2019/2/18 16:16 */public class TxSend { public static final String QUEUE_NAME = \"TX_QUEUE\"; public static void main(String[] args) throws IOException, TimeoutException { Channel channel = MqFactory.getChannel(); channel.queueDeclare(QUEUE_NAME, false, false, false, null); String data = \"I love you\"; try { // 设置事务 channel.txSelect(); channel.basicPublish(\"\", QUEUE_NAME, null, data.getBytes()); // 模拟出错 int i = 3 / 0; // 提交事务 channel.txCommit(); } catch (Exception e) { // 出错回滚 do something channel.txRollback(); System.out.println(\"error: rollback\"); } MqFactory.close(); }} Confirm模式Confirm 模式是通过RabbitMQ服务器的回调，来确认消息是否发送成功，好处在于是异步的，并且对于系统开销很小 开启Confirm模式通过 confirmSelect 来开启，有三种模式：waitForConfirms： 发一条： 发一批： 代码 单条 Confirm 模式 12345678channel.confirmSelect();String data = \"I love you\";channel.basicPublish(\"\", QUEUE_NAME, null, data.getBytes());// 判断是否发送成功if (!channel.waitForConfirms()) { // 发送出错，do something System.out.println(\"send error\");} 批量 Confirm 模式 12345678910channel.confirmSelect();for(int i = 0; i &lt; 10; i++){ String data = \"I love you \" + i; channel.basicPublish(\"\", QUEUE_NAME, null, data.getBytes());}// 判断是否发送成功if (!channel.waitForConfirms()) { // 发送出错，do something System.out.println(\"send error\");} 异步模式Channel 对象提供的 ConfirmListener() 回调方法只包含 deliveryTag(当前 Chanel 发出的消息序列号)，我们需要自己为每一个 Channel 维护一个 unconfirm 的消息序号集合，每 publish 一条数据，集合中元素加1，每回调一次 handleAck 方法，unconfirm 集合删掉相应的一条(multiple=false)或多条(multiple=true)记录。从程序运行效率上看，这个 unconfirm 集合最好采用有序集合 SortedSet 存储结构 1234567891011121314151617181920212223242526272829303132// 开启 confirm 机制channel.confirmSelect();// 申明消息确认序号集合final SortedSet&lt;Long&gt; confirmSet = Collections.synchronizedSortedSet(new TreeSet&lt;Long&gt;());// 添加服务器响应监听channel.addConfirmListener(new ConfirmListener() { // 没有问题的 @Override public void handleAck(long deliveryTag, boolean multiple) throws IOException { doSomething(deliveryTag, multiple, confirmSet); } @Override public void handleNack(long deliveryTag, boolean multiple) throws IOException { doSomething(deliveryTag, multiple, confirmSet); } private void doSomething(long deliveryTag, boolean multiple, SortedSet&lt;Long&gt; confirmSet) { if (multiple) { confirmSet.headSet(deliveryTag + 1).clear(); } else { confirmSet.remove(deliveryTag); } }});// 发送消息for (int i = 0; i &lt; 10; i++) { long seqNo = channel.getNextPublishSeqNo(); String data = \"I love you \" + i; channel.basicPublish(\"\", QUEUE_NAME, null, data.getBytes()); confirmSet.add(seqNo);}","link":"/2019/02/18/MQ/RabbitMQ/Consumer-Acknowledgements-and-Publisher-Confirms/"}],"tags":[{"name":"java","slug":"java","link":"/tags/java/"},{"name":"selenium","slug":"selenium","link":"/tags/selenium/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"django","slug":"django","link":"/tags/django/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"RabbitMQ","slug":"RabbitMQ","link":"/tags/RabbitMQ/"},{"name":"Java","slug":"Java","link":"/tags/Java/"}],"categories":[{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"Python 基础","slug":"Python/Python-基础","link":"/categories/Python/Python-基础/"},{"name":"Python Web","slug":"Python/Python-Web","link":"/categories/Python/Python-Web/"},{"name":"MQ","slug":"MQ","link":"/categories/MQ/"},{"name":"RabbitMQ","slug":"MQ/RabbitMQ","link":"/categories/MQ/RabbitMQ/"}]}